# Longest Increasing Subsequence

최장 증가 부분 수열을 뜻한다.


{ 30, 40, 1, 2, 4, 70 } 이라고 있을 때, LIS는 {1, 2, 4, 70} 이다.

LIS는 O(N^2) 에 의해서 구할 수 있다. (2차원 배열 DP 사용)

arr[시작지점을 나타내는 값][끝지점을 나타내는 값] 으로 2차원 배열을 구성하여 메모이제이션 하면 쉽게 구할 수 있다.

문제는 O(NlogN) 의 방식인데,

O(NlogN) 방식에서 LIS 의 **길이** 를 구하는 방법은 다음과 같다.

1. 현재 탐색중인 배열의 인덱싱까지의 길이를 갖는 배열 초기화
2. 해당 배열에 arr[0]을 삽입
3. i=1 부터 

## O(NlogN) 안에 길이를 찾는 방법

n=k 일때 최대한 많은 원소를 받을 수 있는 최적화된 lis를 구하지 않는다면 다음 값을 인덱싱할때 문제가 있다.

그 최적화된 lis를 구할 때는 lower_bound가 쓰이고 그 방법에 이분탐색이 쓰인다.