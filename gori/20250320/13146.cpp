/**
9 
9 8 7 6 5 6 7 8 9
5, 6, 7, 8 최소 : 4번
최소 값이면서, 오목한 부분 (아래 볼록) 을 먼저 채우는게 최소 조건
히스토그램 문제와 비슷?
-> 단조 증가/감소 스택? -> 단조 증가 / 감소 스택을 각각 넣어서 결과를 비교해서 더 최솟값을 채택하는 방향?
9 8 7 6 5 6 7 8 9

반례? 9 8 1 7 6 5 4 5 6 7 8 9 정답 : 6 + 5 = 11
감소 스택 + 차이값만큼 더하기 -> 증가하는게 나오면 더 높은값으로 교체? - 9 8 1 
9 8 1 (6)7 6 5 4 (1)5 (1)6 (1)7 (1)8 (1)9 = 11
2. 그러면 차이 + size 값이 될까? 11
9
9 8 7(6) 6 5 5
감소스택인데, 더 높은 값이 나오면 차이만큼 정답에 더하고, 그 값으로 교체하기.
스택에 넣는거는 그냥 연쇄적으로 빼도 됨.

1 2 3 9 8 7 6 5 4 3 2 1 - 333(8) 9 (8) = 정답은 일단, 16
1 2(1) 3(1) 9(6) 8 7 6 5 4 3 2 1 => size - 1 + 차이들값이 16이 됨. 아무래도 9 자체는 도착값이다보니 1 빼는게 맞는듯?

예시 0
3
9 5 1

8

예시 1
9 
9 8 7 6 5 6 7 8 9

4

예시 2
12
9 8 1 7 6 5 4 5 6 7 8 9 

11

반례2

12
17 15 1 13 11 9 7 9 11 13 15 17

22

반례3 : size 로 하기에는 무리가 있음 

3
1 9 1

정답 : 16

9 1 -> 최대 최소 간 차이를 계산할까? -> 그렇다고 이걸로 결정하기엔 무리가 있음

반례4 : 중간에 배열값이 감소하다 증가할 때, 

*/
#include <bits/stdc++.h>
using namespace std;

int a[1000001];

int main() { 
    cin.tie(0)->sync_with_stdio(0); cout.tie(0);
    int n; cin>>n;
    stack<int> st;

    int result = 0;
    for(int i=0; i<n; ++i) {
        cin>>a[i];
        if (!st.empty()) {
            if (st.top() < a[i]) {
                result += a[i] - st.top();
            }
            while(!st.empty() && st.top() <= a[i]) {
                st.pop();
            }
        }
        
        st.push(a[i]);
    }
    int max, min = st.top();
    while (!st.empty()) {
        if (st.size() == 1) {
            max = st.top();
        }
        st.pop();
    }
    result += max - min;
    cout<<result;
}    